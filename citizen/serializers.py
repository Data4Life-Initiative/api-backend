import datetime
import threading

from rest_framework import serializers

from authentication.models import FCMPushNotificationRegistrationToken
from citizen.utils import update_citizen_user_info_to_iam, send_hotspot_proximity_notifications
from core.custom_fields import TimeStampField
from core.models import CitizenDiseaseRelation, WellnessStatusOutcome, CitizenPushNotifications, \
    CitizenHistoricLocationDiseaseRelation, Disease
from patient.serializers import HistoricLocationDataSerializer


class CitizenHistoricLocationDataSerializer(HistoricLocationDataSerializer):
    location_name = serializers.CharField(max_length=250)


class CitizenSerializer(serializers.ModelSerializer):
    """
    CitizenSerializer

    Serializes the citizen data
    """
    id = serializers.CharField(source='citizen.id', read_only=True)
    email = serializers.CharField(read_only=True, source='citizen.user.email')
    mobile_number = serializers.CharField(
        source='citizen.mobile_number', read_only=True)
    fullname = serializers.CharField(
        max_length=50, required=False, source='citizen.fullname')

    # date of birth
    dob = serializers.CharField(source='citizen.dob', required=False)

    # citizen home location
    home_latitude = serializers.FloatField(
        required=False, source='citizen.home_latitude')
    home_longitude = serializers.FloatField(
        required=False, source='citizen.home_longitude')

    wellness = serializers.CharField(required=False)

    is_location_sync_enabled = serializers.BooleanField(required=False)

    class Meta:
        model = CitizenDiseaseRelation
        fields = (
            'id', 'email', 'fullname', 'dob', 'home_latitude', 'home_longitude', 'wellness',
            'mobile_number', 'is_location_sync_enabled')

    def validate_dob(self, dob):
        """
        Validates date of birth

        :param dob:
        :return:
        """
        try:
            datetime.datetime.strptime(dob, '%d-%m-%Y')
        except ValueError:
            raise serializers.ValidationError(
                "Incorrect date format, should be dd-mm-yyyy")
        return dob

    def validate_wellness(self, wellness):
        """
        Validates whether the provided wellness status is present in the database

        :param wellness:
        :return:
        """
        if len(wellness) > 0:
            if WellnessStatusOutcome.objects.filter(outcome__iexact=wellness).count() == 0:
                raise serializers.ValidationError(
                    'Please provide a valid wellness status !')
        return wellness

    def update(self, instance, validated_data):
        """
        Updates the citizen profile

        :param instance:
        :param validated_data:
        :return:
        """

        citizen_data = validated_data.get('citizen')

        if citizen_data:
            instance.citizen.fullname = citizen_data.get(
                'fullname', instance.citizen.fullname)

            # updating the fullname of citizen in keycloak IAM
            threading.Thread(target=update_citizen_user_info_to_iam, args=(instance,)).start()

            instance.citizen.dob = citizen_data.get(
                'dob', instance.citizen.dob)
            instance.citizen.home_latitude = citizen_data.get(
                'home_latitude', instance.citizen.home_latitude)
            instance.citizen.home_longitude = citizen_data.get(
                'home_longitude', instance.citizen.home_longitude)
            instance.citizen.is_location_sync_enabled = citizen_data.get('is_location_sync_enabled',
                                                                         instance.citizen.is_location_sync_enabled)
            instance.citizen.save()

        instance.wellness = validated_data.get('wellness', instance.wellness)
        instance.save()

        return instance


class QRSerializer(serializers.Serializer):
    """
    This serializer is the output of create qr code
    """
    file_type = serializers.CharField(max_length=5)
    image_base64 = serializers.CharField(max_length=300)


class PushNotificationDeviceRegistrationTokenSerializer(serializers.Serializer):
    """
    Serializes push notification device registration token data for firebase

    registration_id - For sending push notifications to mobile devices (iOS, Android),
    we require a push notification registration ID unique to the
    device, associated with FCM or APNS(iOS). This changes quiet often

    device_id - Unique identifier for a device generated by iOS and android,
    the device ID doesn't change.
    """
    registration_id = serializers.CharField()
    device_id = serializers.CharField()

    def create(self, validated_data):
        user = validated_data.pop('user')
        registration_id = validated_data.get('registration_id')
        device_id = validated_data.get('device_id')

        # For the given device_id and user object, delete all the previous GCMDevice records
        FCMPushNotificationRegistrationToken.objects.filter(user__id=user.id, device_id=device_id).delete()

        return FCMPushNotificationRegistrationToken.objects.create(device_id=device_id,
                                                                   registration_id=registration_id,
                                                                   user=user,
                                                                   cloud_message_type="FCM")

    def update(self, instance, validated_data):
        pass


class PushNotificationTokenDeleteSerializer(serializers.Serializer):
    """
    Serializes the request payload for deleting all push notification tokens for a particular device ID
    """
    device_id = serializers.CharField()


class PushNotificationListingSerializer(serializers.ModelSerializer):
    """
    Serializes notification query set for a particular citizen for listing
    """
    id = serializers.CharField(read_only=True)
    type = serializers.CharField()
    title = serializers.CharField()
    body = serializers.CharField(max_length=500)
    is_read = serializers.BooleanField()
    timestamp = serializers.SerializerMethodField()

    def get_timestamp(self, instance):
        """
        Returns the UTC timestamp

        :param instance:
        :return:
        """
        return int(instance.added_on.timestamp())

    class Meta:
        model = CitizenPushNotifications
        fields = ('id', 'type', 'title', 'body', 'is_read', 'timestamp')


class CitizenHistoricLocationDiseaseRelationSerializer(serializers.ModelSerializer):
    """
    Serializes the citizen historic location data
    """
    id = serializers.CharField(read_only=True)
    timestamp = TimeStampField()

    class Meta:
        model = CitizenHistoricLocationDiseaseRelation
        fields = ('id', 'lat', 'long', 'location_name', 'timestamp')

    def create(self, validated_data):
        """
        Records historic location of citizen to database

        :param validated_data:
        :return:
        """
        try:
            disease = Disease.objects.get(name="COVID-19")
        except Disease.DoesNotExist as e:
            raise serializers.ValidationError('Unable to fetch diseases. Initialize disease db')

        citizen = validated_data.pop('citizen')
        timestamp = validated_data.pop('timestamp')

        # Check if the location is in proximity of patient historic location
        #  if in proximity, send notifications, also check the delay between last notification
        threading.Thread(target=send_hotspot_proximity_notifications,
                         args=(validated_data.get('lat'), validated_data.get('long'), citizen)).start()

        return CitizenHistoricLocationDiseaseRelation.objects.create(**validated_data,
                                                                     recorded_date_time=timestamp,
                                                                     citizen=citizen, disease=disease)

    def update(self, instance, validated_data):
        """
        Updates historic location of citizen

        :param instance:
        :param validated_data:
        :return:
        """

        instance.lat = validated_data.get('lat', instance.lat)
        instance.long = validated_data.get('long', instance.long)
        instance.location_name = validated_data.get('location_name', instance.location_name)
        instance.recorded_date_time = validated_data.get('timestamp', instance.recorded_date_time)
        instance.save()

        # Check if the location is in proximity of patient historic location
        #  if in proximity, send notifications, also check the delay between last notification
        threading.Thread(target=send_hotspot_proximity_notifications,
                         args=(instance.lat, instance.long, instance.citizen)).start()

        return instance
